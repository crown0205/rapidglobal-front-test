import { useQuery } from "react-query";

import { Inter } from "next/font/google";
import Head from "next/head";

import { axiosInstance } from "@/network";
// import styles from "@/styles/Home.module.css";
import { IProduct, Product } from "@dto/product.model.dto";

import useGlobalModalStore from "@/store/modal";

import clsx from "clsx";
import { SetStateAction, useEffect, useState } from "react";
import ProductModal from "@/components/molecules/Modal/ProductModal";
import Button from "@/components/atoms/Button";
import ProductTable from "@/components/molecules/ProductTable";

const inter = Inter({ subsets: ["latin"] });

// IDEA : next를 이용하는 이유에서 빠른 렌더를 하기 위해서는 어떤 방식을 할지 선택
// getServerSideProps
// getStaticProps

// TODO
// 11. error 처리
// 12. 반응형 처리
// 13. refectory ( 코드 정리 )
//      - 컴포넌트 분리
//      - 코드 정리
//        - api 호출 부분
//      - 주석 정리
//      - 타입 정리
//      - css 정리
//      - 변수명 정리
//      - 함수명 정리
//      - 파일명 정리
//      - 폴더명 정리

// 14. 테스트 코드 작성

// TODO : 컴포넌트 분리
// button
// table
// modal
// input
// select ?? 필요한 곳이 있나??
// image
// layout
// card
// form
// list

export type IOrderBy =
  | "price"
  | "productTitle"
  | "uploadedAt"
  | "viewCount"
  | "none"
  | undefined;

export type Sort = "desc" | "asc" | "none";

export default function Home() {
  // FIXME : 페이지 네이션 될때 리랜더 되는 부분이 전체적이여서 확인 필요
  // FIXME : sortList 값 incoding 하는 방식 체크해서 더 좋은 방법 찾기
  // FIXME : 정렬 아이콘 위치 수정하기

  // NOTE : 콘텐츠 갯수 => 추후에 useState로 관리
  // TODO : take => limit ( contentLength ) => 한번에 보여줄 갯수

  const contentLength = 10;
  const [page, setPate] = useState(1);
  const [orderBy, setOrderBy] = useState<IOrderBy>("none");
  const [sort, setSort] = useState<Sort>("none");
  const [isModalState, setIsModalState] = useState(false);
  const [product, setProduct] = useState<Product | null>(null);

  // NOTE : 정렬 기준 저장
  useEffect(() => {
    if (localStorage.getItem("orderBy")) {
      setOrderBy(localStorage.getItem("orderBy") as IOrderBy);
      setSort(localStorage.getItem("sort") as Sort);
    }
  }, []);

  // TODO : useHook으로 분리하기
  // api 호출부분 최적화
  const {
    data: productListData,
    error,
    isLoading,
  } = useQuery(
    ["products", page, orderBy, sort],
    async (): Promise<IProduct> => {
      // REVIEW :"/api/product/list?skip=0&take=10&sortList=[{%22viewCount%22:%22desc%22}]"
      // FIXME : api url을 어떻게 관리할지 확인 필요 ( 최적화 필요 )
      const { data } = await axiosInstance(
        `/api/product/list?skip=${
          (page - 1) * contentLength
        }&take=${contentLength}${
          orderBy !== "none" ? `&sortList=[{"${orderBy}":"${sort}"}]` : ""
        }`
      );
      const { productList, totalCount } = data;
      return { productList, totalCount: totalCount ?? 1 };
    },
    {
      onError: (error) => {
        console.error(error);
      },
      refetchOnWindowFocus: false,
    }
  );

  const handleSortSave = () => {
    if (orderBy && orderBy !== "none" && sort !== "none") {
      // FIXME : 저장 하는 방식 수정하기
      // {orderBy: "price", sort: "desc"}
      // sortBy : {orderBy: "price", sort: "desc"} 이렇게 localStorage에 저장
      localStorage.setItem("orderBy", orderBy);
      localStorage.setItem("sort", sort);
    }
  };

  const handleSortReset = () => {
    if (localStorage.getItem("orderBy")) {
      localStorage.removeItem("orderBy");
      localStorage.removeItem("sort");
    }

    if (orderBy !== "none" || sort !== "none") {
      setOrderBy("none");
      setSort("none");
    }
  };

  const buttonData = [
    {
      title: "정렬 기준 저장",
      styles: "bg-slate-500 text-white",
      onclick: handleSortSave,
    },
    {
      title: "초기화",
      styles: "bg-slate-500 text-white",
      onclick: handleSortReset,
    },
  ];

  return (
    <>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main
        className={clsx(
          `px-6 py-4 w-full h-full flex flex-col gap-[20px] items-center justify-center`,
          inter.className
        )}
      >
        {/* NOTE : layout */}
        <div className="flex gap-2 w-[80%] justify-end max-w-">
          {buttonData.map((button) => (
            <Button
              key={button.title}
              size="small"
              style={button.styles}
              onClick={button.onclick}
            >
              {button.title}
            </Button>
          ))}
        </div>

        <ProductTable
          sort={sort}
          setSort={setSort}
          orderBy={orderBy}
          setOrderBy={setOrderBy}
          data={productListData}
          setProduct={setProduct}
          setIsModalState={setIsModalState}
        />

        {/* TODO 
            페이지 네이션을 위한 컴포넌트를 만들어야 함 
            데이터의 총 갯수와 페이지당 보여줄 갯수를 받아서 페이지네이션을 만들어야 함 
            해당 페이지 활성화 효과 주기 
        */}
        <div className="flex gap-2 justify-end w-[80%]">
          {/* totalCount와 contentLength값으로 몇개의 페이지가 나오는지 구하기 */}
          {productListData ? (
            Array.from({
              length: Math.ceil(productListData.totalCount / contentLength),
            }).map((_, index) => {
              return (
                <Button
                  key={index}
                  style={clsx(
                    "bg-slate-500 text-white",
                    index + 1 === page && "bg-slate-700",
                    index + 1 !== page && "hover:bg-slate-600"
                  )}
                  onClick={() => setPate(index + 1)}
                >
                  {index + 1}
                </Button>
              );
            })
          ) : (
            <Button
              style={clsx("bg-slate-500 text-white", {
                "bg-slate-300": 1 === page,
              })}
            >
              {page}
            </Button>
          )}
        </div>

        {/* NOTE : ITEM MODAL */}
        <ProductModal
          isModalState={isModalState}
          product={product}
          onClose={() => {
            setIsModalState(false);
          }}
        />
      </main>
    </>
  );
}
